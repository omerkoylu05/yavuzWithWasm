#include <iostream>
#include <stdio.h>
#include <cstring>
#include <limits>
#include "./src/libchess/position.hpp"
#include <map>
// #include <emscripten/bind.h>

extern "C" {

using namespace std;
using namespace libchess;

char* startFen=(char *)"rnbqkbnr/pppppppp/8/8/8/8/PPPPPPPP/RNBQKBNR w KQkq - 0 1";
char* example=(char *)"r1b1k1nr/p2p1pNp/n2B4/1p1NP2P/6P1/3P1Q2/P1P1K3/q5b1";
int depth=3;
    Side s=Side::White;
    map<char, float> pieceValues{
        {'p',0.100},
        {'n',0.320},
        {'b',0.330},
        {'r',0.500},
        {'q',0.900},
        {'k',10.000},
    };

    struct piecePoints
    {
        float p[64];//{0.576727569103241, 0.2789781391620636, 0.10527501255273819, 0.9304110407829285, 0.4342900216579437, 0.88233482837677, 0.43935298919677734, 0.13738687336444855, 0.2179419994354248, 0.05482347682118416, 0.6011371612548828, 0.33029940724372864, 0.6795569062232971, 0.1179158091545105, 0.2843586802482605, 0.5598865747451782, 0.9692965149879456, 0.07096811383962631, 0.7067887783050537, 0.7630795240402222, 0.6964371800422668, 0.9965690970420837, 0.7679583430290222, 0.5013885498046875, 0.9592451453208923, 0.8319034576416016, 0.000300348736345768, 0.0928078442811966, 0.5522891283035278, 0.8342328071594238, 0.7856402397155762, 0.6915126442909241, 0.09585659950971603, 0.7311244606971741, 0.04978826642036438, 0.6316251754760742, 0.2783946990966797, 0.8541174530982971, 0.18817579746246338, 0.24902483820915222, 0.3582240641117096, 0.5598024129867554, 0.02519228495657444, 0.40483707189559937, 0.5617195963859558, 0.18483604490756989, 0.24486304819583893, 0.7691978216171265, 0.10840273648500443, 0.8724150657653809, 0.7534438371658325, 0.1109558716416359, 0.6042889356613159, 0.5214217901229858, 0.7746327519416809, 0.43294423818588257, 0.9949281215667725, 0.5085234045982361, 0.6918474435806274, 0.9655224680900574, 0.6291819214820862, 0.18036513030529022, 0.8562790155410767, 0.750663936138153};
        float r[64];//{0.15132956206798553, 0.9562641382217407, 0.15238896012306213, 0.5656793713569641, 0.6289060711860657, 0.24263568222522736, 0.394066721200943, 0.7317265868186951, 0.5853054523468018, 0.126755952835083, 0.182489275932312, 0.9926334619522095, 0.48960548639297485, 0.974685549736023, 0.64317387342453, 0.805695116519928, 0.20138736069202423, 0.05554979667067528, 0.1599443405866623, 0.6169253587722778, 0.9530680775642395, 0.023429706692695618, 0.5621697306632996, 0.16518846154212952, 0.25676023960113525, 0.0403519906103611, 0.9539088606834412, 0.9905017614364624, 0.7077089548110962, 0.9004297256469727, 0.21434937417507172, 0.09746293723583221, 0.43598395586013794, 0.9366720914840698, 0.12848053872585297, 0.9048042297363281, 0.887006938457489, 0.42393386363983154, 0.28986984491348267, 0.9468417167663574, 0.6277375221252441, 0.13432705402374268, 0.8413866758346558, 0.27556484937667847, 0.89089035987854, 0.7755575180053711, 0.8968674540519714, 0.049299176782369614, 0.06592154502868652, 0.9717850685119629, 0.8605408668518066, 0.052618950605392456, 0.8715561032295227, 0.12589679658412933, 0.6066619753837585, 0.9922980666160583, 0.7868055701255798, 0.36538931727409363, 0.20724591612815857, 0.6524477005004883, 0.42479944229125977, 0.5099965929985046, 0.64543217420578, 0.8061701059341431};
        float n[64];//{0.6547726392745972, 0.03746868297457695, 0.5975323915481567, 0.7148551940917969, 0.11392056941986084, 0.22810828685760498, 0.7585249543190002, 0.01613635942339897, 0.8342009782791138, 0.9638910889625549, 0.40882939100265503, 0.49357104301452637, 0.23148401081562042, 0.974537193775177, 0.8120964765548706, 0.48056474328041077, 0.7499817609786987, 0.4999009966850281, 0.2696193754673004, 0.9214273691177368, 0.6843142509460449, 0.46229490637779236, 0.9761943221092224, 0.6453600525856018, 0.9654648303985596, 0.67964768409729, 0.5504593253135681, 0.9107996821403503, 0.15703441202640533, 0.4598940312862396, 0.8491466641426086, 0.8935784697532654, 0.9637239575386047, 0.7753881216049194, 0.7290675640106201, 0.6377750635147095, 0.7730503678321838, 0.45406630635261536, 0.8562645316123962, 0.9022650122642517, 0.8070880174636841, 0.8535223603248596, 0.058354102075099945, 0.13585741817951202, 0.522010087966919, 0.4763700067996979, 0.5688227415084839, 0.9331283569335938, 0.12329649925231934, 0.18619099259376526, 0.08573446422815323, 0.71668541431427, 0.8080707788467407, 0.12054985761642456, 0.2904132902622223, 0.039381980895996094, 0.2996828258037567, 0.42114099860191345, 0.19069616496562958, 0.8213852047920227, 0.5308060646057129, 0.3230167627334595, 0.18496529757976532, 0.943205595016479};
        float b[64];//{0.9745004773139954, 0.004017216619104147, 0.79071444272995, 0.4457109868526459, 0.5923790335655212, 0.9383643865585327, 0.5990854501724243, 0.33324578404426575, 0.5840423703193665, 0.629799485206604, 0.7434347867965698, 0.2539406716823578, 0.16339589655399323, 0.8576861023902893, 0.1873207986354828, 0.028603961691260338, 0.011596214026212692, 0.4491288959980011, 0.18663185834884644, 0.527526319026947, 0.8830012083053589, 0.2857256829738617, 0.7873705625534058, 0.16650427877902985, 0.12234274297952652, 0.9752839207649231, 0.045954108238220215, 0.6151629090309143, 0.8643084168434143, 0.05176989361643791, 0.814497172832489, 0.4769093990325928, 0.3733178973197937, 0.37605032324790955, 0.8766949772834778, 0.6852185130119324, 0.4587056040763855, 0.9352624416351318, 0.7635436058044434, 0.2165224254131317, 0.17587411403656006, 0.5473088622093201, 0.34668612480163574, 0.6964541077613831, 0.5869625210762024, 0.960105299949646, 0.2763943374156952, 0.9077088236808777, 0.07542826235294342, 0.20504625141620636, 0.9875769019126892, 0.24282751977443695, 0.941658616065979, 0.6449582576751709, 0.7076069116592407, 0.7928717136383057, 0.16058781743049622, 0.012780467979609966, 0.9968019723892212, 0.13442134857177734, 0.8736700415611267, 0.5830984711647034, 0.6221668720245361, 0.9912794828414917};
        float q[64];//{0.9256289601325989, 0.028342846781015396, 0.28581735491752625, 0.8692803382873535, 0.06568960845470428, 0.20131249725818634, 0.12448873370885849, 0.6311572194099426, 0.5921640992164612, 0.0023381682112812996, 0.0050093624740839005, 0.09995218366384506, 0.5856830477714539, 0.49697956442832947, 0.9670823812484741, 0.5897628664970398, 0.9084944725036621, 0.4854172170162201, 0.8753719329833984, 0.014298632740974426, 0.03095100075006485, 0.9045411944389343, 0.1814417690038681, 0.70802241563797, 0.13436259329319, 0.14675995707511902, 0.727666437625885, 0.6732568740844727, 0.89598149061203, 0.4006224274635315, 0.36620792746543884, 0.587419331073761, 0.4006577134132385, 0.5651716589927673, 0.44371503591537476, 0.3647707998752594, 0.4321471154689789, 0.9871566295623779, 0.9287400841712952, 0.6791667938232422, 0.9111633896827698, 0.42877474427223206, 0.7863984704017639, 0.6057357788085938, 0.8780423402786255, 0.7428126335144043, 0.6378113031387329, 0.764319658279419, 0.9666756391525269, 0.44858318567276, 0.8742258548736572, 0.13564741611480713, 0.37778642773628235, 0.23847302794456482, 0.22440530359745026, 0.6717073321342468, 0.9872837066650391, 0.049956321716308594, 0.8760327696800232, 0.1584647297859192, 0.593098521232605, 0.9203189611434937, 0.8574860692024231, 0.8919987678527832};
        float k[64];//{0.8197425603866577, 0.049891550093889236, 0.8089708089828491, 0.5225654244422913, 0.9408397674560547, 0.934968888759613, 0.2947562336921692, 0.5567499399185181, 0.8950421810150146, 0.7676355838775635, 0.9773789048194885, 0.01774243824183941, 0.7075367569923401, 0.23012524843215942, 0.709421694278717, 0.5634449124336243, 0.14193128049373627, 0.9668498635292053, 0.5054851174354553, 0.8712572455406189, 0.15996722877025604, 0.8891531825065613, 0.6432088613510132, 0.4985962510108948, 0.17942678928375244, 0.9398179650306702, 0.9375724792480469, 0.032628800719976425, 0.26546090841293335, 0.7357555627822876, 0.5942652225494385, 0.4752066135406494, 0.8389691114425659, 0.13519060611724854, 0.06649095565080643, 0.9395666122436523, 0.9906858205795288, 0.8907250761985779, 0.8956394195556641, 0.9627807140350342, 0.12419424951076508, 0.6964847445487976, 0.11938244104385376, 0.28113511204719543, 0.9701142907142639, 0.7414084672927856, 0.2532627284526825, 0.28375452756881714, 0.7409723401069641, 0.9381637573242188, 0.7669289112091064, 0.32945311069488525, 0.40775543451309204, 0.03494706004858017, 0.41542941331863403, 0.9852554202079773, 0.7961292862892151, 0.790386974811554, 0.8282918334007263, 0.6930482983589172, 0.0704377070069313, 0.01933472976088524, 0.8004707098007202, 0.4495481848716736};
    };
    struct piecePoints pPoints;
    // vector<float> nodeTree{};
    int set_depth(int d) {
        depth=d;
        return 0;
    }
    float get_pointSquare(char c,int index) {
        switch (c)
        {
        case 'p':            
            return pPoints.p[index];
            break;
        case 'n':            
            return pPoints.n[index];
            break;
        case 'b':            
            return pPoints.b[index];
            break;
        case 'r':            
            return pPoints.r[index];
            break;
        case 'q':            
            return pPoints.q[index];
            break;
        case 'k':            
            return pPoints.k[index];
            break;
        default:
        return 0.0;
            break;
        }
        return 0.0;
    }
    int set_piecePoints(float **vals) {
        for (int p=0;p<64;p++) {
            pPoints.p[p]=vals[0][p];
            pPoints.r[p]=vals[1][p];
            pPoints.n[p]=vals[2][p];
            pPoints.b[p]=vals[3][p];
            pPoints.q[p]=vals[4][p];
            pPoints.k[p]=vals[5][p];
        }
        return 0;
    }

    float* get_points(int index) {
        switch (index)
        {
        case 0:
            return pPoints.p;
            break;
        case 1:
            return pPoints.r;
            break;
        case 2:
            return pPoints.n;
            break;
        case 3:
            return pPoints.b;
            break;
        case 4:
            return pPoints.q;
            break;
        case 5:
            return pPoints.k;
            break;
        default:
            break;
        }
        return NULL;
    }

    float calcGain(Position pos) {
        float value=0.0;
        // for (int i=0;i<64;i++) {
        //     const auto sq = Square(i);
        //     const auto bb = Bitboard{sq};
        //     Side opponent=!s;
        //     for (int v=0;v<6;v++) {

        //         if (pos.pieces(s, Piece(v))&bb||pos.pieces(opponent,Piece(v))&bb) {
        //             int coef=0;
        //             pos.pieces(s,Piece(v))&bb?coef=1:coef=-1;
        //             switch (v)
        //             {
        //             case 0:
        //                 value+=pPoints.p[i]*pieceValues[v]*coef;
        //                 break;
        //             case 1:
        //                 value+=pPoints.n[i]*pieceValues[v]*coef;
        //                 break;
        //             case 2:
        //                 value+=pPoints.b[i]*pieceValues[v]*coef;
        //                 break;
        //             case 3:
        //                 value+=pPoints.r[i]*pieceValues[v]*coef;
        //                 break;
        //             case 4:
        //                 value+=pPoints.q[i]*pieceValues[v]*coef;
        //                 break;
        //             case 5:
        //                 value+=pPoints.k[i]*pieceValues[v]*coef;
        //                 break;
        //             default:
        //                 break;
        //             }
        //         }
        //     }
        // }
        // char *fen=(char *)(pos.get_fen());
        string fen=pos.get_fen();
        int n = fen.length();
 
        // declaring character array
        char fenc[n + 1];
 
        // copying the contents of the
        // string to char array
        strcpy(fenc, fen.c_str());
        int index=0;
        // cout<<fen<<endl;
        for (int i=0;i<sizeof(fenc);i++) {
            int coef=1;
            if (s==Side::Black) coef=-1;
            // cout<<fen.at(i)<<endl;
            if (fenc[i]==' ') break;
            int c=int(fenc[i]);
            if (c>57) {
                    if (c>=65&&c<=122) {
                        char type='?';
                        if (c>97) {
                            type=char(c);
                            coef*=-1;
                            } else {
                            type=char(c+32);
                        }
                        value+=(get_pointSquare(type,index)*pieceValues[type])*coef;
                        index++;
                    }
                } else {
                    if (c!=47) index+=(c-48);
                }
        }
        return value;
    }

    float minmax(string fen, int dpth, float alpha, float beta, bool maximizingPlayer) {
        Position pxf(fen);
        if (dpth == 0) {

            return calcGain(pxf);
        }
        if (maximizingPlayer) {
            float value = -numeric_limits<double>::infinity();
            vector<Move> moves=pxf.legal_moves();
            for (const auto m: moves ) {
                pxf.makemove(m);
                value = max(value, minmax(pxf.get_fen(), dpth - 1, alpha, beta, false));
                pxf.undomove();
                if (value >= beta)
                    break;
                alpha = max(alpha, value);
            }
            return value;
        } else {
            float value = numeric_limits<double>::infinity();
            vector<Move> moves=pxf.legal_moves();
            for (const auto m: moves ) {
                pxf.makemove(m);
                value = min(value, minmax(pxf.get_fen(), dpth - 1, alpha, beta, true));
                pxf.undomove();
                if (value <=alpha)
                    break;
                beta = min(beta, value);
            }
            return value;
        }
    }
    char* selectBest(char* fen) {
        startFen=fen;
        string f(fen);
        // return fen;
        Position pos(f);
        vector<float> nodeTree={};
        Move bestMove;
        float bestGain=-numeric_limits<float>::infinity();
        vector<Move> moves=pos.legal_moves();
        int idx=0;
        for (const auto m : moves) {
            pos.makemove(m);
            float val=minmax(pos.get_fen(),depth-1,-numeric_limits<float>::infinity(),numeric_limits<float>::infinity(),false);
            // cout<<val<<endl;
            pos.undomove();
            if (val>bestGain) {
                bestGain=val;
                bestMove=m;
            }
        }

        string bData=bestMove.operator std::string();
        char *ret=new char[bData.length()+1];
        strcpy(ret,bData.c_str());
        return ret;
        // // char *ret;
        // return ret;
    }

    int main() {
        // string s(startFen);
        char* m=selectBest(startFen);
        // // char* f=(char *)"test.txt";
        // // initValues(f);
        // // Position pos(s);
        // // cout<<s;
        // // char *a=selectBest(startFen);
        // // // if (pos.board[0][0][0]=='r') cout<<"true"<<endl;
        // // // cout<<pos;
        cout<<m;
        return 0;
    } 

}